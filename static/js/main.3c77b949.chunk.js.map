{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["KnnClassifierComponent","React","Component","props","_this3","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","detectFrame","video","model","detect","then","predictions","renderPredictions","requestAnimationFrame","ctx","videoCanvasRef","current","getContext","clearRect","canvas","width","height","font","textBaseline","forEach","prediction","x","bbox","y","strokeStyle","lineWidth","strokeRect","fillStyle","textWidth","measureText","class","textHeight","parseInt","fillRect","fillText","createRef","state","undefined","videoWidth","videoHeight","NUM_CLASSES","TOPK","infoTexts","training","modelPromise","classifier","image","tf","fromPixels","infer","_this4","logits","addExample","getNumClasses","predictClass","res","i","classIndex","style","fontWeight","classExampleCount","getClassExampleCount","conf","confidences","innerText","concat","innerHTML","map","element","index","value","slice","length","highest","sort","a","b","document","body","background","dispose","animate","bind","_this5","onreadystatechange","readyState","setupGui","setupCam","_this6","_loop","div","createElement","appendChild","marginBottom","button","addEventListener","setState","previousState","objectSpread","infoText","push","navigator","mediaDevices","getUserMedia","Error","getElementById","audio","facingMode","stream","srcObject","Promise","resolve","_this7","onloadedmetadata","setupCamera","webCamPromise","cocoSsd","mobilenetModule","knnClassifier","all","values","_this8","catch","error","console","react_default","id","autoPlay","playsInline","muted","className","ref","TensorFlowComponents","App_KnnClassifierComponent","Boolean","window","location","hostname","match","ReactDOM","render","src_App","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.3c77b949.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\n\nimport * as cocoSsd from '@tensorflow-models/coco-ssd';\n\nimport * as mobilenetModule from '@tensorflow-models/mobilenet';\nimport * as tf from '@tensorflow/tfjs';\nimport * as knnClassifier from '@tensorflow-models/knn-classifier';\n\nclass CocoObjectDetection extends React.Component {\n\n  constructor(props) {\n    super(props);\n    // this.imageRef = React.createRef();\n    this.videoRef = React.createRef();\n    // this.imageCanvasRef = React.createRef();\n    this.videoCanvasRef = React.createRef();\n\n    this.state = {\n      predictions: [],\n      imageStatus: \"loading\"\n    }\n  }\n\n  componentDidMount() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      const webCamPromise = navigator.mediaDevices\n        .getUserMedia({\n          audio: false,\n          video: {\n            facingMode: \"user\"\n          }\n        })\n        .then(stream => {\n          window.stream = stream;\n          this.videoRef.current.srcObject = stream;\n          return new Promise((resolve, reject) => {\n            this.videoRef.current.onloadedmetadata = () => {\n              resolve();\n            };\n          });\n        });\n\n      const modelPromise = cocoSsd.load();\n      Promise.all([modelPromise, webCamPromise])\n        .then(values => {\n          this.detectFrame(this.videoRef.current, values[0]);\n        })\n        .catch(error => {\n          console.error(error);\n        });\n    }\n  }\n\n  detectFrame = (video, model) => {\n    model.detect(video).then(predictions => {\n      this.renderPredictions(predictions);\n      requestAnimationFrame(() => {\n        this.detectFrame(video, model);\n      });\n    });\n  };\n\n  renderPredictions = predictions => {\n    const ctx = this.videoCanvasRef.current.getContext(\"2d\");\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    // Font options.\n    const font = \"16px sans-serif\";\n    ctx.font = font;\n    ctx.textBaseline = \"top\";\n    predictions.forEach(prediction => {\n      const x = prediction.bbox[0];\n      const y = prediction.bbox[1];\n      const width = prediction.bbox[2];\n      const height = prediction.bbox[3];\n      // Draw the bounding box.\n      ctx.strokeStyle = \"#00FFFF\";\n      ctx.lineWidth = 4;\n      ctx.strokeRect(x, y, width, height);\n      // Draw the label background.\n      ctx.fillStyle = \"#00FFFF\";\n      const textWidth = ctx.measureText(prediction.class).width;\n      const textHeight = parseInt(font, 10); // base 10\n      ctx.fillRect(x, y, textWidth + 4, textHeight + 4);\n    });\n\n    predictions.forEach(prediction => {\n      const x = prediction.bbox[0];\n      const y = prediction.bbox[1];\n      // Draw the text last to ensure it's on top.\n      ctx.fillStyle = \"#000000\";\n      ctx.fillText(prediction.class, x, y);\n    });\n  };\n\n  // cropToCanvas = () => {\n  //   const image = this.imageRef.current;\n  //   const canvas = this.imageCanvasRef.current;\n  //   const ctx = canvas.getContext(\"2d\");\n  //   const naturalWidth = image.naturalWidth;\n  //   const naturalHeight = image.naturalHeight;\n\n  //   canvas.width = image.width;\n  //   canvas.height = image.height;\n\n  //   ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n  //   if (naturalWidth > naturalHeight) {\n  //     ctx.drawImage(\n  //       image,\n  //       (naturalWidth - naturalHeight) / 2,\n  //       0,\n  //       naturalHeight,\n  //       naturalHeight,\n  //       0,\n  //       0,\n  //       ctx.canvas.width,\n  //       ctx.canvas.height\n  //     );\n  //   } else {\n  //     ctx.drawImage(\n  //       image,\n  //       0,\n  //       (naturalHeight - naturalWidth) / 2,\n  //       naturalWidth,\n  //       naturalWidth,\n  //       0,\n  //       0,\n  //       ctx.canvas.width,\n  //       ctx.canvas.height\n  //     );\n  //   }\n  // };\n\n  // onImageLoad() {\n  //   cocoSsd.load()\n  //     .then(model => model.detect(this.imageRef.current))\n  //     .then(predictions => {\n  //       console.log(predictions);\n  //       this.cropToCanvas();\n\n  //       const font = \"16px sans-serif\";\n  //       const ctx = this.imageCanvasRef.current.getContext('2d');\n  //       ctx.font = font;\n  //       ctx.textBaseline = \"top\";\n\n  //       predictions.forEach(prediction => {\n  //         const x = prediction.bbox[0];\n  //         const y = prediction.bbox[1];\n  //         const width = prediction.bbox[2];\n  //         const height = prediction.bbox[3];\n  //         // Draw the bounding box.\n  //         ctx.strokeStyle = \"#00FFFF\";\n  //         ctx.lineWidth = 4;\n  //         ctx.strokeRect(x, y, width, height);\n  //         // Draw the label background.\n  //         ctx.fillStyle = \"#00FFFF\";\n  //         const textWidth = ctx.measureText(prediction.class).width;\n  //         const textHeight = parseInt(font, 10); // base 10\n  //         ctx.fillRect(x, y, textWidth + 4, textHeight + 4);\n  //       });\n\n  //       predictions.forEach(prediction => {\n  //         const x = prediction.bbox[0];\n  //         const y = prediction.bbox[1];\n  //         ctx.fillStyle = \"#000000\";\n  //         ctx.fillText(prediction.class, x, y);\n  //       });\n\n  //       this.setState({ predictions });\n  //     });\n  // }\n\n  render() {\n    return (\n      <div className=\"App\">\n        {/* <img\n          alt=\"Cat\"\n          ref={this.imageRef}\n          onLoad={this.onImageLoad(this)}\n          id=\"image\"\n          width=\"500px\"\n          crossOrigin=\"anonymous\"\n          src=\"https://upload.wikimedia.org/wikipedia/commons/6/66/An_up-close_picture_of_a_curious_male_domestic_shorthair_tabby_cat.jpg\"\n        /> */}\n        <video\n          className=\"size\"\n          autoPlay\n          playsInline\n          muted\n          ref={this.videoRef}\n          width=\"600\"\n          height=\"500\"\n        />\n        {/* <canvas\n          className=\"image-canvas\"\n          ref={this.imageCanvasRef}\n          width=\"500\"\n          height=\"500\"\n        /> */}\n        <canvas\n          className=\"size\"\n          ref={this.videoCanvasRef}\n          width=\"600\"\n          height=\"500\"\n        />\n      </div>\n    );\n  }\n}\n\nclass KnnClassifierComponent extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this.videoCanvasRef = React.createRef();\n\n    this.state = {\n      video: undefined,\n      videoWidth: 300,\n      videoHeight: 250,\n      NUM_CLASSES: 3,\n      TOPK: 3,\n      infoTexts: [],\n      training: -1,\n      modelPromise: undefined,\n      classifier: undefined\n    }\n  }\n\n  async animate() {\n    // Get image data from video element\n    const video = this.state.video;\n    const image = tf.browser.fromPixels(video);\n    let logits;\n    // 'conv_preds' is the logits activation of MobileNet.\n    const infer = () => this.state.modelPromise.infer(image, 'conv_preds');\n\n    // Train class if one of the buttons is held down\n    if (this.state.training !== -1) {\n      logits = infer();\n      // Add current image to classifier\n      this.state.classifier.addExample(logits, this.state.training);\n    }\n\n    // If the classifier has examples for any classes, make a prediction!\n    const numClasses = await this.state.classifier.getNumClasses();\n    if (numClasses > 0) {\n      logits = infer();\n\n      const res = await this.state.classifier.predictClass(logits, this.state.TOPK);\n      for (let i = 0; i < this.state.NUM_CLASSES; i++) {\n        // Make the predicted class bold\n        if (res.classIndex === i) {\n          this.state.infoTexts[i].style.fontWeight = 'bold';\n        } else {\n          this.state.infoTexts[i].style.fontWeight = 'normal';\n        }\n\n        const classExampleCount = this.state.classifier.getClassExampleCount();\n        // Update info text\n        if (classExampleCount[i] > 0) {\n          const conf = res.confidences[i] * 100;\n          this.state.infoTexts[i].innerText = ` ${classExampleCount[i]} examples - ${conf}%`;\n\n          const innerHTML = this.state.infoTexts.map((element, index) => {\n            const value = parseInt(element.innerText.slice(element.innerHTML.length - 4, element.innerHTML.length - 1));\n\n            return {\n              index,\n              value: value ? value : 0  }\n            }\n          );\n\n          const highest = innerHTML.sort((a, b) => b.value - a.value)[0]\n          switch (highest.index) {\n            case 0:\n              document.body.style.background = \"#288340\";\n              break;\n            case 1:\n              document.body.style.background = \"#9B1617\";\n              break;\n            case 2:\n              document.body.style.background = \"#083C84\";\n              break;\n          }\n        }\n      }\n    }\n\n    image.dispose();\n    if (logits != null) {\n      logits.dispose();\n    }\n\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n  componentDidMount() {\n    document.onreadystatechange = () => {\n      if (document.readyState === 'complete') {\n        this.setupGui()\n        this.setupCam()\n      }\n    };\n  }\n\n  setupGui() {\n    // Create training buttons and info texts\n    for (let i = 0; i < this.state.NUM_CLASSES; i++) {\n      const div = document.createElement('div');\n      document.body.appendChild(div);\n      div.style.marginBottom = '10px';\n\n      // Create training button\n      const button = document.createElement('button');\n      button.innerText = 'Treinar ' + i;\n      div.appendChild(button);\n\n      // Listen for mouse events when clicking the button\n      button.addEventListener('click', () => {\n        this.setState(previousState => ({\n          ...previousState,\n          training: i\n        }));\n\n        this.animate();\n\n        requestAnimationFrame(() => {\n          this.setState(previousState => ({\n            ...previousState,\n            training: -1\n          }));\n        });\n      });\n\n      // Create info text\n      const infoText = document.createElement('span');\n      infoText.innerText = ' Nenhum exemplo criado';\n      div.appendChild(infoText);\n      this.state.infoTexts.push(infoText);\n    }\n  }\n\n  async setupCamera() {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n      throw new Error(\n          'Browser API navigator.mediaDevices.getUserMedia not available');\n    }\n\n    this.state.video = document.getElementById('video');\n    this.state.video.width = this.state.videoWidth;\n    this.state.video.height = this.state.videoHeight;\n\n    const stream = await navigator.mediaDevices.getUserMedia({\n      'audio': false,\n      'video': {\n        facingMode: 'user',\n        width: this.state.videoWidth,\n        height: this.state.videoHeight,\n      },\n    });\n    this.state.video.srcObject = stream;\n\n    return new Promise((resolve) => {\n      this.state.video.onloadedmetadata = () => {\n        resolve(this.state.video);\n      };\n    });\n  }\n\n  async setupCam() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      const webCamPromise = await this.setupCamera();\n      const modelPromise = cocoSsd.load();\n\n      this.setState(previousState => ({\n        ...previousState,\n        modelPromise: mobilenetModule.load(2),\n        classifier: knnClassifier.create()\n      }));\n\n      Promise.all([this.state.modelPromise, webCamPromise, modelPromise])\n        .then(values => {\n          this.setState(previousState => ({\n            ...previousState,\n            modelPromise: values[0]\n          }));\n\n          this.detectFrame(values[1], values[2]);\n        })\n        .catch(error => {\n          console.error(error);\n        });\n    }\n  }\n\n  detectFrame = (video, model) => {\n    model.detect(video).then(predictions => {\n      this.renderPredictions(predictions);\n      requestAnimationFrame(() => {\n        this.detectFrame(video, model);\n      });\n    });\n  };\n\n  renderPredictions = predictions => {\n    const ctx = this.videoCanvasRef.current.getContext(\"2d\");\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    // Font options.\n    const font = \"16px sans-serif\";\n    ctx.font = font;\n    ctx.textBaseline = \"top\";\n    predictions.forEach(prediction => {\n      const x = prediction.bbox[0];\n      const y = prediction.bbox[1];\n      const width = prediction.bbox[2];\n      const height = prediction.bbox[3];\n      // Draw the bounding box.\n      ctx.strokeStyle = \"#00FFFF\";\n      ctx.lineWidth = 4;\n      ctx.strokeRect(x, y, width, height);\n      // Draw the label background.\n      ctx.fillStyle = \"#00FFFF\";\n      const textWidth = ctx.measureText(prediction.class).width;\n      const textHeight = parseInt(font, 10); // base 10\n      ctx.fillRect(x, y, textWidth + 4, textHeight + 4);\n    });\n\n    predictions.forEach(prediction => {\n      const x = prediction.bbox[0];\n      const y = prediction.bbox[1];\n      // Draw the text last to ensure it's on top.\n      ctx.fillStyle = \"#000000\";\n      ctx.fillText(prediction.class, x, y);\n    });\n  };\n\n  render() {\n    return (\n      <div>\n        <video\n          id=\"video\"\n          autoPlay\n          playsInline\n          muted\n        />\n        <canvas\n          className=\"size\"\n          ref={this.videoCanvasRef}\n          width=\"300\"\n          height=\"250\"\n        />\n      </div>\n    );\n  }\n}\n\n\nclass TensorFlowComponents extends React.Component {\n  render() {\n    return (\n      <div>\n        {/* <CocoObjectDetection /> */}\n        <KnnClassifierComponent />\n      </div>\n    )\n  }\n}\n\nexport default TensorFlowComponents;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport TensorFlowComponents from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<TensorFlowComponents />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}